\chapter{Desarrollo de bloques driver}
\label{cap:capitulo4}
Como ya se ha explicado, VisualCircuit es una plataforma de programación online mediante el uso de bloques, pero para que esté actualizado
se deben añadir bloques nuevos que ofrezcan esas nuevas funciones y añadirlos a las listas de bloques estándar que la página ofrece.\\
En este capítulo se profundizará en el funcionamiento de la plataforma VisualCircuit así como en el proceso seguido para desarrollar nuevos
bloques para poder añadir ROS2 a la misma.

Los bloques drivers que se van a implementar son para la cámara, el láser, la odometría y los motores usando un topic de ROS2, ya sea
para suscribirse (sensores) o para publicar (actuadores).\\
A continuación se explica el proceso seguido para desarrollar cada uno de los drivers.

\section{Bloques sensores}
\label{sec:blocks_sensores}

Para desarrollar los bloques correspondientes a los sensores, primero  una plantilla para sensores y después implementaremos cada uno de
los sensores a partir de ella. Esta plantilla va a consistir de un \textit{input} para activar/desactivar el bloque, habilitando el uso de máquinas
de estados con nuestro bloque, un \textit{output} para compartir la medida del sensor con otros bloques y una constante donde se definirá
el \textit{topic} permitiendo al usuario cambiarlo sin modificar el código del bloque y habilitando su uso tanto para robots simulados como reales.\\
\begin{figure} [H]
  \begin{center}
      \includegraphics[width=10cm]{figs/c4/VC_driver_blocks.png}
  \end{center}
  \caption[Modelo bloque driver sensores]{Modelo para crear bloques driver de sensores.}
  \label{fig:VC_driver_model}
\end{figure}

En cuanto al código que usaremos, seguiremos las indicaciones de los manuales de
ROS2-humble\footnote{\url{https://docs.ros.org/en/humble/Tutorials/Beginner-Client-Libraries/Writing-A-Simple-Py-Publisher-And-Subscriber.html\#write-the-subscriber-node}}
para usar nodos suscriptores/publicadores con python. El código general para los bloques de sensores (suscriptores) será el siguiente:

\begin{code}[H]
  \begin{lstlisting}[language=python]
    import numpy as np
    import rclpy
    from rclpy.node import Node
    from cv_bridge import CvBridge
    from std_msgs/msg import String #SENSOR MSG TYPE
    
    bridge = CvBridge()
    data = None
    
    # ros2 node class
    class SENSORSubscriber(Node):
        def __init__(self, topic):
            super().__init__('sensor_subscriber')
            self.subscription = self.create_subscription(
              String, topic, self.callback, 10)

            self.subscription  # prevent unused variable warning
    
        def callback(self, msg):
            global data
            # Modify msg as needed and save into global variable
            data = msg
  \end{lstlisting}
\end{code}
\begin{code}[H]
  \begin{lstlisting}[language=python]
    def main(inputs, outputs, parameters, synchronise):
        global data
        auto_enable = False
        try:
            enable = inputs.read_number('Enable')
        except Exception:
            auto_enable = True
        rclpy.init()
        sensor_sub = SENSORSubscriber(parameters.read_string("ROSTopic"))

        try:
            while auto_enable or inputs.read_number('Enable'):
                data =  None
                rclpy.spin_once(sensor_sub)
                if data is not None:
                    outputs.share_string("Output", data)
                synchronise()
        except Exception as e:
            print('Error:', e)
            pass
        finally:
            print("Exiting")
            synchronise()     
            SENSORSubscriber.destroy_node()
            rclpy.shutdown()
  \end{lstlisting}
  \caption[Modelo de código para bloques drivers]{Modelo de código para bloques drivers.}
  \label{cod:bloques_drivers_sensors_total}
\end{code}

Si lo analizamos por partes, la clase \textbf{\textit{SENSORSubscriber}} (código \ref{cod:bloques_drivers_sensors_node_class}) contiene una función
para inicializar la clase, donde se define el nombre del nodo, se crea el suscriptor y se inicia el suscriptor, y una función callback a la que se
llamará de forma periódica, actualizando el valor de la variable global a la última medida del sensor.

\begin{code}[H]
  \begin{lstlisting}[language=python]
    # ros2 node class
    class SENSORSubscriber(Node):
        def __init__(self, topic):
            super().__init__('sensor_subscriber')
            self.subscription = self.create_subscription(
              String, topic, self.callback, 10)

            self.subscription  # prevent unused variable warning
    
        def callback(self, msg):
            global data
            # Modify msg as needed and save into global variable
            data = msg
  \end{lstlisting}
  \caption[Clase del nodo suscriptor para bloques drivers]{Clase del nodo suscriptor para los bloques drivers.}
  \label{cod:bloques_drivers_sensors_node_class}
\end{code}

En la función main (código \ref{cod:bloques_drivers_sensors_main_general}) tenemos dos partes, la secuencia \textit{try-except} donde se declara
si se está usando una máquina de estados (\textit{enable}) o si debe estar activo constantemente (\textit{autoenable} al haber dado error la lectura
del cable de \textit{enable}).
En la segunda parte (bucle \textit{while}) se reinicia el valor de la variable global y se llama a \textit{``rclpy.spin\_once()"} para obtener la
última medida del sensor y compartirla por el cable \textit{``output"}.

\begin{code}[H]
  \begin{lstlisting}[language=python]
    def main(inputs, outputs, parameters, synchronise):
        global data
        auto_enable = False
        try:
            enable = inputs.read_number('Enable')
        except Exception:
            auto_enable = True
        rclpy.init()
        sensor_sub = SENSORSubscriber(parameters.read_string("ROSTopic"))

        try:
            while auto_enable or inputs.read_number('Enable'):
                data =  None
                rclpy.spin_once(sensor_sub)
                if data is not None:
                    outputs.share_string("Output", data)
  \end{lstlisting}
  \caption[Función main para bloques drivers de sensores]{Función main para los bloques drivers de sensores.}
  \label{cod:bloques_drivers_sensors_main_general}
\end{code}

Una vez que tenemos el modelo general para estos bloques, hay que modificarlos para que funcionen con la cámara, el láser y la odometría. Para ello,
cambiaremos el tipo de mensaje que se envía, y haremos que el \textit{callback} obtenga del mensaje de ROS sólo la información que nos interesa,
ya que éste viene con cabeceras y otros datos.\\
\newpage
\subsection{Bloque cámara ROS2}
\label{subsec:cameraROS2}

Para el bloque cámaraROS2, el mensaje es del tipo \textit{sensor\_msgs.msg.Image} que,
usando el comando ``\lstinline|ros2 interface show sensor_msgs/msg/Image|", se puede ver cuál es su estructura:
\begin{figure} [H]
  \begin{center}
      \includegraphics[width=10cm]{figs/c4/image_struct.png}
  \end{center}
  \caption[Estructura mensaje Image]{Estructura del tipo de mensaje \textit{sensor\_msgs/msg/Image}.}
  \label{fig:image_struct}
\end{figure}
Como se observa en la figura \ref{fig:image_struct}, la imagen que obtendremos estará en el campo \textit{data} del mensaje. Los hilos de VisualCircuit
comparten las imágenes como un array de numpy, por lo que será necesario convertir la imagen a imagen de numpy y después a un array de numpy.
Para ello, ROS tiene una función llamada \textit{CvBridge}\footnote{\textbf{CvBridge}: \url{http://wiki.ros.org/cv_bridge}}, que permite transformar un mensaje del
tipo \textit{sensor\_msgs/msg/Image} a una imagen de numpy\footnote{\textbf{Numpy}: \url{https://numpy.org/}}, que se pasará a array de numpy usando la
función \textit{numpy.asarray()}.
\begin{code}[H]
  \begin{lstlisting}[language=python]
    class CamSubscriber(Node):
        def __init__(self, topic):
            super().__init__('cam_subscriber')
            self.subscription = self.create_subscription(
                Image, topic, self.callback, 10)
            self.subscription  # prevent unused variable warning
        def callback(self, msg):
            global frame
            frame = np.asarray(bridge.imgmsg_to_cv2(msg, "bgr8"), dtype=np.uint8)
  \end{lstlisting}
  \caption[Clase del nodo suscriptor para cámara]{Clase del nodo suscriptor para la cámara.}
  \label{cod:cam_node_class}
\end{code}
En cuanto a la función main, sólo habría que cambiar la función que se usa para compartir para adaptarla al tipo de mensaje, en este caso una imagen:
\begin{code}[H]
  \begin{lstlisting}[language=python]
  while auto_enable or inputs.read_number('Enable'):
      frame =  None
      rclpy.spin_once(camera_subscriber)
      if frame is not None:
          outputs.share_image("Out", frame)
  \end{lstlisting}
  \caption[Cambios main bloque cámara]{Cambios a la función main del bloque driver de la cámara.}
  \label{cod:cam_main_changes}
\end{code}
Finalmente, se realizaron pruebas tanto en simulador como en el robot real para probar que el bloque funcionase correctamente, como se puede ver en las
siguientes capturas:
\begin{figure} [H]
  \begin{center}
      \includegraphics[width=7cm]{figs/c4/camS1.png}
      \includegraphics[width=7cm]{figs/c4/camS2.png}
  \end{center}
  \caption[Secuencia bloque cámara ROS2 simulado]{Secuencia de imágenes del bloque cámara ROS2 con TurtleBot2 simulado. Imagenes obtenidas de Youtube\footnotemark.}
  \label{fig:vid_camS}
\end{figure}
\footnotetext{\textbf{Vídeo bloque cámara simulación}: \url{https://www.youtube.com/watch?v=a5J6Qccc5xk&t=73s&ab_channel=Tapi1300}}

\begin{figure} [H]
  \begin{center}
      \includegraphics[width=7cm]{figs/c4/camR1.png}
      \includegraphics[width=7cm]{figs/c4/camR2.png}
  \end{center}
  \caption[Secuencia bloque cámara ROS2 real]{Secuencia de imágenes del bloque cámara ROS2 con TurtleBot2 real. Imagenes obtenidas de Youtube\footnotemark.}
  \label{fig:vid_camR}
\end{figure}
\footnotetext{\textbf{Vídeo bloque cámara real}: \url{https://www.youtube.com/watch?v=MNaFWD9-ats&ab_channel=Tapii}}

\subsection{Bloque láser ROS2}
\label{subsec:laserROS2}
% ****** LASER
Para el láser, se seguirá un proceso similar al que se ha usado con la cámara. Para ello se comienza revisando la estructura del tipo de mensaje, e
 este caso usando ``\lstinline|ros2 interface show sensor_msgs/msg/LaserScan|":
\begin{figure} [H]
  \begin{center}
      \includegraphics[width=10cm]{figs/c4/laserscan_struct.png}
  \end{center}
  \caption[Estructura mensaje LaserScan]{Estructura del tipo de mensaje \textit{sensor\_msgs/msg/LaserScan}.}
  \label{fig:laserscanstruct}
\end{figure}
Se observa en la figura \ref{fig:laserscanstruct} que la lectura del láser estará en el campo \textit{ranges} del mensaje, que es un \textit{array}
de \textit{floats}, por lo que para guardarlo en un array local se usará la función de python ``\textit{.extend()}", que permite añadir una entrada
más a un array. Esto se hará en el callback, ya que es donde se actualiza el valor de la variable global.
\begin{code}[H]
  \begin{lstlisting}[language=python]
    class LaserSubscriber(Node):
        def __init__(self, topic):
            super().__init__('laser_subscriber')
            self.subscription = self.create_subscription(
                LaserScan, topic, self.callback, 10)
            self.subscription  # prevent unused variable warning
        def callback(self, msg):
            global measure
            measure = []
            for i in range(len(msg.ranges)):
                measure.extend((str(msg.ranges[i]),))
  \end{lstlisting}
  \caption[Clase del nodo suscriptor para láser]{Clase del nodo suscriptor para el láser.}
  \label{cod:laser_node_class}
\end{code}

\newpage

En cuanto a la función main, sólo habría que cambiar la función \textit{share}, adaptándola de nuevo al tipo de mensaje, en este caso un array:
\begin{code}[H]
  \begin{lstlisting}[language=python]
    while auto_enable or inputs.read_number('Enable'):
        measure = None
        rclpy.spin_once(laser_subscriber)
        if measure is not None:
            outputs.share_array("Out",measure)   
        synchronise()  
  \end{lstlisting}
  \caption[Cambios main bloque láser]{Cambios a la función main del bloque driver del láser.}
  \label{cod:laser_main_changes}
\end{code}

Para probar el correcto funcionamiento del bloque, se ha creado un circuito simple en el que se reciban los mensajes del topic del láser y se impriman
en una terminal los valores recibidos, tanto con el robot real como con el simulado:

\begin{figure} [H]
  \begin{center}
      \includegraphics[width=10cm]{figs/c4/laserC.png}
  \end{center}
  \caption[Circuito pruebas bloque láser ROS2]{Circuito de pruebas del bloque laserROS2.}
  \label{fig:laser_circuit}
\end{figure}

\begin{figure} [H]
    \begin{center}
      \includegraphics[width=7cm]{figs/c4/laserS.png}
      \includegraphics[width=7cm]{figs/c4/laserR.png}
    \end{center}
    \caption[Ejemplo bloque láser ROS2]{Ejemplo del bloque laserROS2 con TurtleBot2 simulado y real. Imagenes obtenidas de Youtube\footnotemark.}
    \label{fig:vid_laserR}
\end{figure}
\footnotetext{\textbf{Vídeo bloque láser real}: \url{https://www.youtube.com/watch?v=-MweaxUVsCg&ab_channel=Tapii}}

\newpage

\subsection{Bloque odometría ROS2}
\label{subsec:odomROS2}
% ****** ODOM

El bloque de la odometría debe devolver la posición del robot en el mundo, esto implica coordenadas \textit{X} e \textit{Y}, al igual que la
posición angular del eje \textit{Z}. En este caso, el tipo de mensaje del \textit{topic /odom} es \textit{nav\_msgs/msg/Odometry},
cuyos parámetros podemos comprobar mediante el comando ``\lstinline|ros2 interface show nav_msgs/msg/Odometry|" con el siguiente resultado:
\begin{figure} [H]
    \begin{center}
        \includegraphics[width=12cm]{figs/c6/odom_msg.png}
    \end{center}
    \caption[Estructura mensaje Odometría]{Estructura del tipo de mensaje \textit{nav\_msgs/msg/Odometry}.}
    \label{fig:odom_struct}
\end{figure}

En la función \textit{callback} se debe almacenar estos tres valores y enviarlos por el cable de salida usando un array. Los primeros
dos valores se pueden sacar directamente del campo \textit{pose.pose.position} del mensaje, pero la rotación viene dada mediante
cuaterniones, por lo que hay que transformarlo a ángulos de euler y obtener el valor que se busca. Esto se realiza mediante la
función \textit{Rotation} del paquete
\textit{scipy.spatial.transform}\footnote{\textbf{Librería Spicy}: \url{docs.scipy.org/doc/scipy/reference/generated/scipy.spatial.transform.Rotation.html}}
de \textit{python3}.
\begin{code}[H]
    \begin{lstlisting}[language=python]
        def callback(self, msg):
            global odom
            odom[0] = msg.pose.pose.position.x
            odom[1] = msg.pose.pose.position.y
            rot = Rotation.from_quat([msg.pose.pose.orientation.x, msg.pose.pose.orientation.y, msg.pose.pose.orientation.z, msg.pose.pose.orientation.w])
            odom[2] = rot.as_euler('xyz', degrees=True)[2]
    \end{lstlisting}
    \caption[Funciones para obtener la fuerza repulsiva]{Funciones para obtener la fuerza repulsiva.}
    \label{cod:rep_vel}
\end{code}

\section{Bloque MotorDriverROS2}
\label{sec:motordriverros2}
% ******** MOTOR DRIVER
Para desarrollar el bloque MotorDriverROS2 la configuración será distinta de los anteriores, ya que no será necesaria una salida sino una entrada
para recibir las velocidades que mandar al robot. Por esto, habrá un bloque de código, un parámetro para el \textit{topic} de ROS2 y
dos entradas, una para \textit{enable} (máquinas de estados) y otra para las velocidades que se deben enviar.\\

El tipo de mensaje que suelen admitir los robots para su movimiento es ``geometry\_msgs/msg/Twist", y si revisamos su estructura
usando ``\lstinline|ros2 interface show geometry_msgs/msg/Twist|", nos encontraremos lo siguiente:
\begin{figure} [H]
  \begin{center}
      \includegraphics[width=10cm]{figs/c4/twist_struct.png}
  \end{center}
  \caption[Estructura mensaje Twist]{Estructura de tipo de mensaje \textit{geometry\_msgs/msg/Twist}.}
  \label{fig:twist_struct}
\end{figure}

Como se puede ver en la figura \ref{fig:twist_struct}, este tipo de mensajes lleva dos paquetes de 3 floats, el primero para las velocidades
lineales y el segundo para las angulares. Para crear un bloque más general que pueda adaptarse a todo tipo de robots, el bloque recibirá un array
de 6 floats permitiendo introducir velocidades lineales y angulares en las 3 dimensiones que nos permite el mensaje, ya que aunque la mayoría de
robots terrestres sólo usen una velocidad lineal y una angular, así se permite el uso de este bloque con otros robots como drones o robots con ruedas
omnidireccionales.\\

Para poder crear el nodo publicador iremos, al igual que se hizo con el suscriptor, a los manuales de
ROS2-humble\footnote{\url{https://docs.ros.org/en/humble/Tutorials/Beginner-Client-Libraries/Writing-A-Simple-Py-Publisher-And-Subscriber.html\#write-the-publisher-node}}
y a partir de ahí crear el nodo publicador necesario para este bloque.

\begin{code}[H]
  \begin{lstlisting}[language=python]
    import numpy as np
    import rclpy
    from rclpy.node import Node
    from cv_bridge import CvBridge
    from geometry_msgs.msg import Twist

    bridge = CvBridge()
    velocities = 0

    # ros2 node class
    class VelPublisher(Node):
        def __init__(self, topic):
            super().__init__('vel_publisher')
            self.publisher_ = self.create_publisher(Twist, topic, 1)
            timer_period = 0.5  # seconds
            self.timer = self.create_timer(timer_period, self.timer_callback)
        def timer_callback(self):
            global velocities
            msg = Twist()
            try:
                msg.linear.x = float(velocities[0])
                msg.linear.y = float(velocities[1])
                msg.linear.z = float(velocities[2])
                msg.angular.x = float(velocities[3])
                msg.angular.y = float(velocities[4])
                msg.angular.z = float(velocities[5])
            except IndexError:
                print("bad length for input array")
                return
            self.publisher_.publish(msg)

    def main(inputs, outputs, parameters, synchronise):
        global velocities
        auto_enable = False
        try:
            enable = inputs.read_number('Enable')
        except Exception:
            auto_enable = True
        rclpy.init()
        vel_publisher = VelPublisher(parameters.read_string('ROSTopic'))

        while auto_enable or inputs.read_number('Enable'):
            velocities = inputs.read_array('Vels')
            if velocities != None:
                rclpy.spin_once(vel_publisher)
            synchronise()
  \end{lstlisting}
  \caption[Bloque MotorDriverROS2]{Bloque MotorDriverROS2 completo.}
  \label{cod:motordriverros2_all}
\end{code}

\newpage

Al ser un publicador, funciona con un temporizador para publicar el mensaje actualizado. Como se puede ver, se lee un array, se guarda en
la variable global y cuando vuelva a ejecutarse el temporizador, se enviará la última actualización de las velocidades.

Al igual que con los bloques de los sensores, se han realizado pruebas del bloque tanto con el robot simulado como con el robot TurtleBot2 real
para comprobar que en ambos escenarios funcionase sin problemas. En este caso, se han combinado el bloque de la cámara con el bloque MotorDriverROS2
para que se aprecie mejor el movimiento.

\begin{figure} [H]
  \begin{center}
      \includegraphics[width=7cm]{figs/c4/motorS1.png}
      \includegraphics[width=7cm]{figs/c4/motorS2.png}
  \end{center}
  \caption[Secuencia bloque cámara ROS2 simulado]{Secuencia de imágenes del bloque MotorDriverROS2 con TurtleBot2 simulado. Imagenes obtenidas de Youtube\footnotemark.}
  \label{fig:vid_motS}
\end{figure}
\footnotetext{\textbf{Vídeo bloque MotorDriverROS2 simulación}: \url{https://www.youtube.com/watch?v=a5J6Qccc5xk&t=73s&ab_channel=Tapi1300}}

\begin{figure} [H]
  \begin{center}
      \includegraphics[width=7cm]{figs/c4/motorR1.png}
      \includegraphics[width=7cm]{figs/c4/motorR2.png}
  \end{center}
  \caption[Secuencia bloque MotorDriverROS2 real]{Secuencia de imágenes del bloque MotorDriverROS2 con TurtleBot2 real. Imagenes obtenidas de Youtube\footnotemark.}
  \label{fig:vid_motR}
\end{figure}
\footnotetext{\textbf{Vídeo bloque MotorDriverROS2 real}: \url{https://www.youtube.com/watch?v=MNaFWD9-ats&ab_channel=Tapii}}

